---
File: tests/test_summary/test_aggregation.py
---
# tests/test_summary/test_aggregation.py

import pytest
from pathlib import Path
from llamero.summary.concatenative import SummaryGenerator

def create_nested_summaries(root_dir: Path) -> dict[str, Path]:
    """Create a nested directory structure with SUMMARY files."""
    paths = {}
    
    # Create directories
    frontend_dir = root_dir / "frontend"
    src_dir = frontend_dir / "src"
    js_dir = src_dir / "js"
    styles_dir = src_dir / "styles"
    templates_dir = src_dir / "templates"
    
    for dir_path in [frontend_dir, src_dir, js_dir, styles_dir, templates_dir]:
        dir_path.mkdir(parents=True, exist_ok=True)
        paths[dir_path.name] = dir_path
    
    # Create test files with their base paths properly included in the content
    js_files = {
        "main.js": {
            "content": "console.log('main');",
            "path": "frontend/src/js/main.js"
        },
        "utils.js": {
            "content": "export function util() {}",
            "path": "frontend/src/js/utils.js"
        }
    }
    
    styles_files = {
        "main.css": {
            "content": "body { color: black; }",
            "path": "frontend/src/styles/main.css"
        },
        "utils.css": {
            "content": ".util { display: none; }",
            "path": "frontend/src/styles/utils.css"
        }
    }
    
    template_files = {
        "index.html": {
            "content": "<html><body></body></html>",
            "path": "frontend/src/templates/index.html"
        },
        "footer.html": {
            "content": "<footer></footer>",
            "path": "frontend/src/templates/footer.html"
        }
    }
    
    # Write files
    for dir_name, files in [
        ("js", js_files),
        ("styles", styles_files),
        ("templates", template_files)
    ]:
        dir_path = paths[dir_name]
        for name, file_info in files.items():
            file_path = dir_path / name
            file_path.write_text(file_info["content"])
            
            # Create SUMMARY content with proper file paths
            summary_content = []
            summary_content.extend([
                "---",
                f"File: {file_info['path']}",
                "---",
                file_info["content"],
                "\n"
            ])
            
            # Write SUMMARY for each directory
            (dir_path / "SUMMARY").write_text("\n".join(summary_content))
    
    return paths
    
# def test_aggregation_formatting(temp_project_dir):
#     """Test that aggregated summaries maintain correct formatting."""
#     paths = create_nested_summaries(temp_project_dir)
    
#     generator = SummaryGenerator(temp_project_dir)
#     generator.generate_all_summaries()
    
#     src_summary = (paths["src"] / "SUMMARY").read_text()
    
#     # Check proper section formatting
#     sections = src_summary.split("---")
#     for section in sections[1:]:  # Skip first empty section
#         # Each section should follow format: \nFile: path\n---\ncontent\n
#         lines = section.splitlines()
#         assert lines[0].startswith("File: "), f"Section doesn't start with 'File: ': {lines[0]}"
        
#         # Check section structure
#         content = "\n".join(lines[1:])
#         assert content.strip(), "Section content is empty"
#         assert section.endswith("\n"), "Section doesn't end with newline"

def test_basic_aggregation(temp_project_dir):
    """Test basic summary aggregation in a nested directory structure."""
    paths = create_nested_summaries(temp_project_dir)
    
    generator = SummaryGenerator(temp_project_dir)
    summary_files = generator.generate_all_summaries()
    
    # Check that summaries were created at each level
    assert (paths["frontend"] / "SUMMARY").exists()
    assert (paths["src"] / "SUMMARY").exists()
    assert (paths["js"] / "SUMMARY").exists()
    assert (paths["styles"] / "SUMMARY").exists()
    assert (paths["templates"] / "SUMMARY").exists()
    
    # Verify content format
    src_summary = (paths["src"] / "SUMMARY").read_text()
    frontend_summary = (paths["frontend"] / "SUMMARY").read_text()
    
    # Check that delimiters are preserved
    assert "---\nFile:" in src_summary
    assert "---\nFile:" in frontend_summary
    
    # Check that content is propagated up
    js_content = (paths["js"] / "SUMMARY").read_text()
    assert js_content in src_summary
    assert js_content in frontend_summary

def test_aggregation_with_empty_directories(temp_project_dir):
    """Test that empty directories don't affect aggregation."""
    paths = create_nested_summaries(temp_project_dir)
    
    # Add an empty directory
    empty_dir = paths["src"] / "empty"
    empty_dir.mkdir()
    
    generator = SummaryGenerator(temp_project_dir)
    generator.generate_all_summaries()
    
    src_summary = (paths["src"] / "SUMMARY").read_text()
    frontend_summary = (paths["frontend"] / "SUMMARY").read_text()
    
    # Empty directory should not affect content
    assert not (empty_dir / "SUMMARY").exists()
    assert src_summary == frontend_summary

def test_aggregation_content_preservation(temp_project_dir):
    """Test that all content is preserved during aggregation."""
    paths = create_nested_summaries(temp_project_dir)
    
    generator = SummaryGenerator(temp_project_dir)
    generator.generate_all_summaries()
    
    # Get all unique content from leaf SUMMARYs
    leaf_content = set()
    for dir_name in ["js", "styles", "templates"]:
        summary = (paths[dir_name] / "SUMMARY").read_text()
        leaf_content.update(line for line in summary.splitlines() if line.strip())
    
    # Check that all content appears in parent summaries
    src_summary = (paths["src"] / "SUMMARY").read_text()
    frontend_summary = (paths["frontend"] / "SUMMARY").read_text()
    
    for line in leaf_content:
        if line.strip():  # Skip empty lines
            assert line in src_summary
            assert line in frontend_summary

def test_aggregation_with_excluded_directories(temp_project_dir):
    """Test that excluded directories don't affect aggregation."""
    paths = create_nested_summaries(temp_project_dir)
    
    # Create an excluded directory with content
    excluded_dir = paths["src"] / "__pycache__"
    excluded_dir.mkdir()
    (excluded_dir / "cache.pyc").write_text("cache content")
    
    generator = SummaryGenerator(temp_project_dir)
    generator.generate_all_summaries()
    
    src_summary = (paths["src"] / "SUMMARY").read_text()
    
    # Verify excluded content is not present
    assert "cache content" not in src_summary
    assert "__pycache__" not in src_summary



---
File: tests/test_summary/test_concatenative.py
---
# tests/test_summary/test_concatenative.py
import pytest
from pathlib import Path
from llamero.summary.concatenative import SummaryGenerator

@pytest.fixture
def config_project_dir(temp_project_dir):
    """Create a project directory with custom configuration."""
    config_content = """
[project]
name = "test-project"
description = "Test project"
version = "0.1.0"

[tool.summary]
max_file_size_kb = 10
exclude_patterns = [
    '.hidden',
    'excluded_file.txt',
    'temp'
]
include_extensions = [
    '.py',
    '.md',
    '.txt',
    '.custom'
]
exclude_directories = [
    'excluded_dir',
    'temp_dir',
    'data'
]
"""
    (temp_project_dir / "pyproject.toml").write_text(config_content)
    return temp_project_dir

@pytest.fixture
def workflow_project_dir(temp_project_dir):
    """Create a project directory with workflow files."""
    # Create workflow file
    workflow_dir = temp_project_dir / ".github" / "workflows"
    workflow_dir.mkdir(parents=True)
    (workflow_dir / "test.yml").write_text("name: Test")
    
    # Add basic pyproject.toml
    config_content = """
[project]
name = "test-project"
description = "Test project"
version = "0.1.0"
"""
    (temp_project_dir / "pyproject.toml").write_text(config_content)
    return temp_project_dir

@pytest.fixture
def test_files(config_project_dir):
    """Create a set of test files with various extensions and patterns."""
    # Create test files
    files = {
        # Should be included
        'test.py': 'print("Hello")',
        'doc.md': '# Documentation',
        'notes.txt': 'Some notes',
        'special.custom': 'Custom file',
        'nested/test.py': 'nested = True',
        
        # Should be excluded by pattern
        '.hidden/secret.txt': 'secret',
        'excluded_file.txt': 'excluded',
        'temp/data.py': 'temp data',
        
        # Should be excluded by extension
        'script.sh': '#!/bin/bash',
        'data.csv': 'a,b,c',
        
        # Should be excluded by directory
        'excluded_dir/test.py': 'excluded',
        'temp_dir/data.txt': 'temp',
        
        # Should be excluded by size (if >10KB)
        'large.py': 'x' * (11 * 1024)  # 11KB
    }
    
    for path, content in files.items():
        file_path = config_project_dir / path
        file_path.parent.mkdir(parents=True, exist_ok=True)
        file_path.write_text(content)
        
    return config_project_dir

def test_config_loading(config_project_dir):
    """Test that configuration is properly loaded from pyproject.toml."""
    generator = SummaryGenerator(config_project_dir)
    
    assert generator.max_file_size == 10 * 1024
    assert '.hidden' in generator.config['exclude_patterns']
    assert '.custom' in generator.config['include_extensions']
    assert 'excluded_dir' in generator.config['exclude_directories']

def test_file_inclusion_by_extension(test_files):
    """Test that files are correctly included/excluded based on extension."""
    generator = SummaryGenerator(test_files)
    
    # Should include
    assert generator.should_include_file(test_files / 'test.py')
    assert generator.should_include_file(test_files / 'doc.md')
    assert generator.should_include_file(test_files / 'special.custom')
    
    # Should exclude
    assert not generator.should_include_file(test_files / 'script.sh')
    assert not generator.should_include_file(test_files / 'data.csv')

def test_file_exclusion_by_pattern(test_files):
    """Test that files are correctly excluded based on patterns."""
    generator = SummaryGenerator(test_files)
    
    # Should exclude
    assert not generator.should_include_file(test_files / '.hidden/secret.txt')
    assert not generator.should_include_file(test_files / 'excluded_file.txt')
    assert not generator.should_include_file(test_files / 'temp/data.py')

def test_directory_exclusion(test_files):
    """Test that directories are correctly excluded."""
    generator = SummaryGenerator(test_files)
    
    # Should exclude
    assert not generator.should_include_directory(test_files / 'excluded_dir')
    assert not generator.should_include_directory(test_files / 'temp_dir')
    
    # Should include
    assert generator.should_include_directory(test_files / 'nested')

def test_file_size_limits(test_files):
    """Test that files are excluded based on size limits."""
    generator = SummaryGenerator(test_files)
    
    # Small file should be included
    assert generator.should_include_file(test_files / 'test.py')
    
    # Large file should be excluded
    assert not generator.should_include_file(test_files / 'large.py')


# def test_summary_generation_with_config(test_files):
#     """Test that summary generation respects all configuration settings."""
#     # Create test file in root
#     root_test_file = test_files / "test.py"
#     root_test_file.write_text("print('root')")
    
#     generator = SummaryGenerator(test_files)
#     summary_files = generator.generate_all_summaries()
    
#     # Get all generated summaries
#     summaries = {}
#     for summary_file in summary_files:
#         summaries[summary_file] = summary_file.read_text()
    
#     # Check that the right files were included
#     root_summary = test_files / 'SUMMARY'
#     if root_summary in summaries:
#         content = summaries[root_summary]
        
#         # Should include file with correct relative path
#         #assert 'File: test.py' in content, "Root file not found with correct path"
#         assert 'File: nested/test.py' in content, "Nested file not found"
#         assert 'File: src/test_project/main.py' in content, "Project file not found"
        
#         assert 'File: doc.md' in content
#         assert 'File: special.custom' in content
        
#         # Should exclude
#         assert 'excluded_file.txt' not in content
#         assert 'secret.txt' not in content
#         assert 'script.sh' not in content
#         assert 'large.py' not in content

def test_nested_directory_handling(test_files):
    """Test that nested directories are handled correctly."""
    generator = SummaryGenerator(test_files)
    summary_files = generator.generate_all_summaries()
    
    # Check nested directory summary
    nested_summary = test_files / 'nested' / 'SUMMARY'
    assert nested_summary.exists()
    content = nested_summary.read_text()
    
    assert 'File: nested/test.py' in content
    assert 'nested = True' in content

def test_default_config_fallback(temp_project_dir):
    """Test that default configuration is used when no config file exists."""
    # Create a test.py file
    (temp_project_dir / "test.py").write_text("print('test')")
    
    generator = SummaryGenerator(temp_project_dir)
    
    # Check default extensions
    assert generator.should_include_file(temp_project_dir / "test.py")
    
    # Create files with extensions that should be excluded by default
    test_sh = temp_project_dir / "script.sh"
    test_sh.write_text("#!/bin/bash")
    assert not generator.should_include_file(test_sh)
    
    # Check default directory exclusions
    git_dir = temp_project_dir / ".git"
    git_dir.mkdir(exist_ok=True)
    assert not generator.should_include_directory(git_dir)

def test_workflow_directory_mapping(workflow_project_dir):
    """Test that .github/workflows is correctly mapped to github/workflows."""
    generator = SummaryGenerator(workflow_project_dir)
    
    # Add a workflow file
    workflow_dir = workflow_project_dir / ".github" / "workflows"
    (workflow_dir / "test.yml").write_text("name: Test")
    
    summary_files = generator.generate_all_summaries()
    
    # Check that workflow summary was created in mapped location
    mapped_summary = workflow_project_dir / "github" / "workflows" / "SUMMARY"
    assert mapped_summary in summary_files
    
    # Verify content references original path
    content = mapped_summary.read_text()
    assert "File: .github/workflows/test.yml" in content

def test_error_handling(config_project_dir, caplog):
    """Test error handling for unreadable files."""
    caplog.set_level("ERROR")
    
    # Create unreadable file
    bad_file = config_project_dir / "unreadable.py"
    bad_file.write_text("test")
    
    try:
        # Make file unreadable
        bad_file.chmod(0o000)
        
        generator = SummaryGenerator(config_project_dir)
        generator.generate_directory_summary(config_project_dir)
        
        # Check for error message
        for record in caplog.records:
            if (
                record.levelname == "ERROR" 
                and "Error processing" in record.message 
                and "Permission denied" in record.message
            ):
                break
        else:
            pytest.fail("Expected error message not found in logs")
            
    finally:
        # Clean up
        bad_file.chmod(0o644)
        bad_file.unlink()

def test_excluded_directory_files(test_files):
    """Test that files in excluded directories are excluded regardless of extension."""
    # Create a file with valid extension in excluded directory
    excluded_dir = test_files / "data"
    excluded_dir.mkdir(exist_ok=True)
    test_file = excluded_dir / "_excluded_test.py"
    test_file.write_text("print('should be excluded')")
    
    generator = SummaryGenerator(test_files)
    
    # File should be excluded because it's in an excluded directory
    assert not generator.should_include_file(test_file)
    
    # Generate summary and verify file is not included
    summaries = generator.generate_all_summaries()
    for summary_file in summaries:
        content = summary_file.read_text()
        assert "_excluded_test.py" not in content
        assert "should be excluded" not in content



---
File: tests/test_summary/test_python_signatures.py
---
# tests/test_summary/test_python_signatures.py
import pytest
from llamero.summary.python_signatures import SignatureExtractor, generate_python_summary

def test_signature_extraction():
    """Test Python signature extraction."""
    source = """
def test_func(x: int, y: str = "default") -> bool:
    \"\"\"Test function.\"\"\"
    return True

class TestClass:
    \"\"\"Test class.\"\"\"
    def method(self, x: int) -> None:
        \"\"\"Test method.\"\"\"
        pass
    """
    
    extractor = SignatureExtractor()
    signatures = extractor.extract_signatures(source)
    
    assert len(signatures) == 2
    
    # Check function signature
    func = signatures[0]
    assert func.name == "test_func"
    assert func.kind == "function"
    assert len(func.args) == 2
    assert func.returns == "bool"
    assert func.docstring == "Test function."
    
    # Check class signature
    cls = signatures[1]
    assert cls.name == "TestClass"
    assert cls.kind == "class"
    assert cls.docstring == "Test class."
    assert len(cls.methods) == 1
    
    # Check method signature
    method = cls.methods[0]
    assert method.name == "method"
    assert method.kind == "method"
    assert len(method.args) == 2  # including self
    assert method.returns == "None"
    assert method.docstring == "Test method."


def test_generate_python_summary(temp_project_dir):
    """Test Python summary generation."""
    # Create a Python file with known content
    python_file = temp_project_dir / "src" / "test_project" / "main.py"
    python_content = """
def hello():
    \"\"\"Say hello.\"\"\"
    return "Hello, world!"

class TestClass:
    \"\"\"A test class.\"\"\"
    def method(self):
        \"\"\"A test method.\"\"\"
        return True
"""
    python_file.write_text(python_content)
    
    summary = generate_python_summary(temp_project_dir)
    
    # Check summary content - using exact signature format
    expected_fragments = [
        "# Python Project Structure",
        "def hello()",
        'class TestClass'
    ]
    for fragment in expected_fragments:
        assert fragment in summary, f"Missing expected content: {fragment}"



---
File: tests/test_summary/test_size_limits.py
---
# tests/test_summary/test_size_limits.py
import pytest
from pathlib import Path
import os
from llamero.summary.concatenative import SummaryGenerator

def test_file_size_threshold_config(temp_project_dir, monkeypatch):
    """Test that size threshold is properly loaded from config."""
    # Change to temp directory so it's treated as project root
    monkeypatch.chdir(temp_project_dir)
    
    # Update pyproject.toml with size threshold
    config_content = """
[project]
name = "test-project"
description = "Test project"
version = "0.1.0"

[tool.summary]
max_file_size_kb = 10  # 10KB threshold
"""
    (temp_project_dir / "pyproject.toml").write_text(config_content)
    
    generator = SummaryGenerator(temp_project_dir)
    assert generator.max_file_size == 10 * 1024  # Should be converted to bytes

def test_file_size_filtering(temp_project_dir, monkeypatch):
    """Test that files are filtered based on size."""
    # Change to temp directory so it's treated as project root
    monkeypatch.chdir(temp_project_dir)
    
    # Set up config with 1KB threshold
    config_content = """
[project]
name = "test-project"
description = "Test project"
version = "0.1.0"

[tool.summary]
max_file_size_kb = 1  # 1KB threshold
"""
    (temp_project_dir / "pyproject.toml").write_text(config_content)
    
    # Create test files
    small_file = temp_project_dir / "small.py"
    large_file = temp_project_dir / "large.py"
    
    # 500 bytes file (under threshold)
    small_file.write_text("x" * 500)
    
    # 2KB file (over threshold)
    large_file.write_text("x" * 2048)
    
    generator = SummaryGenerator(temp_project_dir)
    
    # Test individual file inclusion
    assert generator.should_include_file(small_file)
    assert not generator.should_include_file(large_file)

def test_directory_summary_with_size_limit(temp_project_dir, monkeypatch):
    """Test that directory summaries respect size limits."""
    # Change to temp directory so it's treated as project root
    monkeypatch.chdir(temp_project_dir)
    
    # Set up config with 1KB threshold
    config_content = """
[project]
name = "test-project"
description = "Test project"
version = "0.1.0"

[tool.summary]
max_file_size_kb = 1
"""
    (temp_project_dir / "pyproject.toml").write_text(config_content)
    
    # Create test files in a subdirectory
    test_dir = temp_project_dir / "test_dir"
    test_dir.mkdir()
    
    small_file = test_dir / "small.py"
    large_file = test_dir / "large.py"
    
    small_content = "def small_function():\n    pass"
    large_content = "x" * 2048  # 2KB of content
    
    small_file.write_text(small_content)
    large_file.write_text(large_content)
    
    generator = SummaryGenerator(temp_project_dir)
    summary = generator.generate_directory_summary(test_dir)
    
    # Summary should include small file but not large file
    assert "small.py" in summary
    assert "small_function" in summary
    assert "large.py" not in summary
    assert large_content not in summary

# def test_size_limit_warning_logging(temp_project_dir, monkeypatch, caplog):
#     """Test that appropriate warnings are logged for skipped files."""
#     # Change to temp directory so it's treated as project root
#     monkeypatch.chdir(temp_project_dir)
#     caplog.set_level("WARNING")
    
#     # Set up config with 1KB threshold
#     config_content = """
# [project]
# name = "test-project"
# description = "Test project"
# version = "0.1.0"

# [tool.summary]
# max_file_size_kb = 1
# """
#     (temp_project_dir / "pyproject.toml").write_text(config_content)
    
#     # Create a large file
#     large_file = temp_project_dir / "large.py"
#     large_file.write_text("x" * 2048)  # 2KB
    
#     generator = SummaryGenerator(temp_project_dir)
#     generator.generate_directory_summary(temp_project_dir)
    
#     # Check that a warning was logged
#     assert any([
#         "Skipping large file" in record.message and "large.py" in record.message
#         for record in caplog.records
#     ])



---
File: tests/test_summary/test_workflow_mapping.py
---
# tests/test_summary/test_workflow_mapping.py
import pytest
from pathlib import Path
from llamero.summary.concatenative import SummaryGenerator

def test_directory_mapping(temp_project_dir):
    """Test that .github/workflows maps to github/workflows."""
    generator = SummaryGenerator(temp_project_dir)
    
    # Test workflow directory mapping
    original = Path(".github/workflows")
    mapped = generator._map_directory(original)
    # We want just the mapped path without the root directory
    mapped_relative = mapped.relative_to(generator.root_dir) if mapped.is_absolute() else mapped
    assert str(mapped_relative) == "github/workflows"
    
    # Test that other directories aren't affected
    normal_dir = Path("src/llamero")
    mapped_normal = generator._map_directory(normal_dir)
    mapped_normal_relative = mapped_normal.relative_to(generator.root_dir) if mapped_normal.is_absolute() else mapped_normal
    assert str(mapped_normal_relative) == str(normal_dir)

def test_workflow_summary_generation(temp_project_dir):
    """Test generation of workflow summaries in mapped location."""
    # Create workflow dir and file
    workflow_dir = temp_project_dir / ".github" / "workflows"
    workflow_dir.mkdir(parents=True)
    
    workflow_content = """
name: Test Workflow
on: [push]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
"""
    (workflow_dir / "test.yml").write_text(workflow_content)
    
    # Generate summaries
    generator = SummaryGenerator(temp_project_dir)
    summary_files = generator.generate_all_summaries()
    
    # Check that summary was created in mapped location
    mapped_summary = temp_project_dir / "github" / "workflows" / "SUMMARY"
    assert mapped_summary in summary_files
    assert mapped_summary.exists()
    
    # Verify content
    content = mapped_summary.read_text()
    assert "File: .github/workflows/test.yml" in content

def test_mixed_directory_handling(temp_project_dir):
    """Test handling of both workflow and non-workflow directories."""
    # Create workflow file
    workflow_dir = temp_project_dir / ".github" / "workflows"
    workflow_dir.mkdir(parents=True)
    (workflow_dir / "test.yml").write_text("name: Test")
    
    # Create regular file
    src_dir = temp_project_dir / "src" / "llamero"
    src_dir.mkdir(parents=True)
    (src_dir / "test.py").write_text("print('test')")
    
    # Generate summaries
    generator = SummaryGenerator(temp_project_dir)
    summary_files = generator.generate_all_summaries()
    
    # Check both summaries
    workflow_summary = temp_project_dir / "github" / "workflows" / "SUMMARY"
    src_summary = src_dir / "SUMMARY"
    
    assert workflow_summary in summary_files
    assert workflow_summary.exists()
    assert src_summary in summary_files
    assert src_summary.exists()
