---
File: tests/conftest.py
---
# tests/conftest.py
import pytest
from pathlib import Path
import tempfile
import shutil
import os
import logging
import sys
from loguru import logger

class InterceptHandler(logging.Handler):
    def emit(self, record):
        # Get corresponding Loguru level if it exists
        try:
            level = logger.level(record.levelname).name
        except ValueError:
            level = record.levelno

        # Find caller from where originated the logged message
        frame, depth = logging.currentframe(), 2
        while frame.f_code.co_filename == logging.__file__:
            frame = frame.f_back
            depth += 1

        logger.opt(depth=depth, exception=record.exc_info).log(level, record.getMessage())

@pytest.fixture(autouse=True)
def setup_logging(caplog):
    """Set up loguru to work with pytest's caplog."""
    # Remove any existing handlers
    logger.remove()
    
    # Add handler that intercepts everything
    logger.add(
        sys.stderr,
        format="{time} | {level} | {module}:{function}:{line} - {message}",
        level="DEBUG"
    )
    
    # Attach loguru to pytest's caplog
    handler_id = logger.add(
        lambda msg: caplog.handler.emit(
            logging.LogRecord(
                name=msg.record["name"],
                level=msg.record["level"].no,
                pathname=msg.record["file"].name,
                lineno=msg.record["line"],
                msg=msg.record["message"],
                args=(),
                exc_info=msg.record["exception"]
            )
        ),
        format="{message}",
        level="DEBUG"
    )
    
    yield
    
    # Clean up
    logger.remove(handler_id)

@pytest.fixture
def temp_project_dir():
    """Create a temporary project directory with a pyproject.toml."""
    with tempfile.TemporaryDirectory() as tmpdir:
        tmp_path = Path(tmpdir)
        
        # Create minimal pyproject.toml
        pyproject_content = """
[project]
name = "test-project"
description = "Test project"
version = "0.1.0"
requires-python = ">=3.11"

[tool.llamero]
verbose = true
"""
        (tmp_path / "pyproject.toml").write_text(pyproject_content)
        
        # Create some test files and directories
        src_dir = tmp_path / "src" / "test_project"
        src_dir.mkdir(parents=True)
        
        # Sample Python file
        (src_dir / "main.py").write_text("""
def hello():
    \"\"\"Say hello.\"\"\"
    return "Hello, world!"

class TestClass:
    \"\"\"A test class.\"\"\"
    def method(self):
        \"\"\"A test method.\"\"\"
        return True
""")
        
        # Sample README
        (tmp_path / "README.md").write_text("# Test Project\n\nThis is a test.")
        
        yield tmp_path

@pytest.fixture
def mock_git_repo(temp_project_dir):
    """Create a temporary git repository."""
    os.chdir(temp_project_dir)
    os.system("git init")
    os.system("git config user.name 'Test User'")
    os.system("git config user.email 'test@example.com'")
    os.system("git add .")
    os.system("git commit -m 'Initial commit'")
    yield temp_project_dir
    os.chdir(os.path.dirname(temp_project_dir))



---
File: tests/test_dir2doc.py
---
from pathlib import Path
import pytest
from llamero.dir2doc import collect_section_templates, compile_template_dir

def test_collect_section_templates(temp_project_dir):
    """Test template collection and ordering."""
    template_dir = temp_project_dir / "templates"
    template_dir.mkdir()
    sections_dir = template_dir / "sections"
    sections_dir.mkdir()
    
    # Create test templates
    templates = ["b.md.j2", "a.md.j2", "c.md.j2"]
    for t in templates:
        (sections_dir / t).write_text("")
    
    # Test default ordering (alphabetical)
    ordered = collect_section_templates(sections_dir)
    assert ordered == sorted(templates)
    
    # Test explicit ordering
    order_config = {
        "c.md.j2": 1,
        "a.md.j2": 2,
        "b.md.j2": 3
    }
    ordered = collect_section_templates(sections_dir, order_config)
    assert ordered == ["c.md.j2", "a.md.j2", "b.md.j2"]
    
    # Test handling of templates not in order config
    (sections_dir / "d.md.j2").write_text("")
    ordered = collect_section_templates(sections_dir, order_config)
    assert "d.md.j2" not in ordered
    
    # Test empty order config
    ordered = collect_section_templates(sections_dir, {})
    assert len(ordered) == 4  # All templates included
    assert ordered == sorted([*templates, "d.md.j2"])

def test_compile_template_dir_with_base(temp_project_dir):
    """Test template compilation with base template."""
    template_dir = temp_project_dir / "templates"
    template_dir.mkdir()
    sections_dir = template_dir / "sections"
    sections_dir.mkdir()
    
    # Create test templates
    base_template = """# {{ project.name }}

{% for template in templates %}
{%- include "sections/" ~ template %}
{% endfor %}"""
    (template_dir / "base.md.j2").write_text(base_template)
    
    section_template = """## Section
This is a test section."""
    (sections_dir / "test.md.j2").write_text(section_template)
    
    # Test compilation
    output_path = temp_project_dir / "OUTPUT.md"
    compile_template_dir(
        template_dir,
        output_path=output_path,
        variables={"project": {"name": "Test Project"}},
        commit=False
    )
    
    # Check output
    output = output_path.read_text()
    assert "# Test Project" in output
    assert "## Section" in output
    assert "This is a test section." in output

def test_compile_template_dir_without_base(temp_project_dir):
    """Test template compilation without base template (fallback mode)."""
    template_dir = temp_project_dir / "templates"
    template_dir.mkdir()
    sections_dir = template_dir / "sections"
    sections_dir.mkdir()
    
    # Create test templates
    templates = {
        "a.md.j2": "## First Section\nThis is first.",
        "b.md.j2": "## Second Section\nThis is second.",
    }
    
    for name, content in templates.items():
        (sections_dir / name).write_text(content)
    
    # Test compilation
    output_path = temp_project_dir / "OUTPUT.md"
    compile_template_dir(
        template_dir,
        output_path=output_path,
        commit=False
    )
    
    # Check output
    output = output_path.read_text()
    assert "## First Section" in output
    assert "## Second Section" in output
    assert "This is first" in output
    assert "This is second" in output

def test_compile_template_dir_with_ordering(temp_project_dir):
    """Test template compilation with explicit ordering."""
    template_dir = temp_project_dir / "templates"
    template_dir.mkdir()
    sections_dir = template_dir / "sections"
    sections_dir.mkdir()
    
    # Create test templates
    templates = {
        "b.md.j2": "## Second\nShould appear second",
        "a.md.j2": "## First\nShould appear first",
    }
    
    for name, content in templates.items():
        (sections_dir / name).write_text(content)
    
    # Test compilation with ordering
    order_config = {
        "a.md.j2": 1,
        "b.md.j2": 2,
    }
    
    output_path = temp_project_dir / "OUTPUT.md"
    compile_template_dir(
        template_dir,
        output_path=output_path,
        order_config=order_config,
        commit=False
    )
    
    # Check output maintains order
    output = output_path.read_text()
    first_pos = output.find("Should appear first")
    second_pos = output.find("Should appear second")
    assert first_pos < second_pos



---
File: tests/test_summary/test_aggregation.py
---
# tests/test_summary/test_aggregation.py

import pytest
from pathlib import Path
from llamero.summary.concatenative import SummaryGenerator

def create_nested_summaries(root_dir: Path) -> dict[str, Path]:
    """Create a nested directory structure with SUMMARY files."""
    paths = {}
    
    # Create directories
    frontend_dir = root_dir / "frontend"
    src_dir = frontend_dir / "src"
    js_dir = src_dir / "js"
    styles_dir = src_dir / "styles"
    templates_dir = src_dir / "templates"
    
    for dir_path in [frontend_dir, src_dir, js_dir, styles_dir, templates_dir]:
        dir_path.mkdir(parents=True, exist_ok=True)
        paths[dir_path.name] = dir_path
    
    # Create test files with their base paths properly included in the content
    js_files = {
        "main.js": {
            "content": "console.log('main');",
            "path": "frontend/src/js/main.js"
        },
        "utils.js": {
            "content": "export function util() {}",
            "path": "frontend/src/js/utils.js"
        }
    }
    
    styles_files = {
        "main.css": {
            "content": "body { color: black; }",
            "path": "frontend/src/styles/main.css"
        },
        "utils.css": {
            "content": ".util { display: none; }",
            "path": "frontend/src/styles/utils.css"
        }
    }
    
    template_files = {
        "index.html": {
            "content": "<html><body></body></html>",
            "path": "frontend/src/templates/index.html"
        },
        "footer.html": {
            "content": "<footer></footer>",
            "path": "frontend/src/templates/footer.html"
        }
    }
    
    # Write files
    for dir_name, files in [
        ("js", js_files),
        ("styles", styles_files),
        ("templates", template_files)
    ]:
        dir_path = paths[dir_name]
        for name, file_info in files.items():
            file_path = dir_path / name
            file_path.write_text(file_info["content"])
            
            # Create SUMMARY content with proper file paths
            summary_content = []
            summary_content.extend([
                "---",
                f"File: {file_info['path']}",
                "---",
                file_info["content"],
                "\n"
            ])
            
            # Write SUMMARY for each directory
            (dir_path / "SUMMARY").write_text("\n".join(summary_content))
    
    return paths
    
# def test_aggregation_formatting(temp_project_dir):
#     """Test that aggregated summaries maintain correct formatting."""
#     paths = create_nested_summaries(temp_project_dir)
    
#     generator = SummaryGenerator(temp_project_dir)
#     generator.generate_all_summaries()
    
#     src_summary = (paths["src"] / "SUMMARY").read_text()
    
#     # Check proper section formatting
#     sections = src_summary.split("---")
#     for section in sections[1:]:  # Skip first empty section
#         # Each section should follow format: \nFile: path\n---\ncontent\n
#         lines = section.splitlines()
#         assert lines[0].startswith("File: "), f"Section doesn't start with 'File: ': {lines[0]}"
        
#         # Check section structure
#         content = "\n".join(lines[1:])
#         assert content.strip(), "Section content is empty"
#         assert section.endswith("\n"), "Section doesn't end with newline"

def test_basic_aggregation(temp_project_dir):
    """Test basic summary aggregation in a nested directory structure."""
    paths = create_nested_summaries(temp_project_dir)
    
    generator = SummaryGenerator(temp_project_dir)
    summary_files = generator.generate_all_summaries()
    
    # Check that summaries were created at each level
    assert (paths["frontend"] / "SUMMARY").exists()
    assert (paths["src"] / "SUMMARY").exists()
    assert (paths["js"] / "SUMMARY").exists()
    assert (paths["styles"] / "SUMMARY").exists()
    assert (paths["templates"] / "SUMMARY").exists()
    
    # Verify content format
    src_summary = (paths["src"] / "SUMMARY").read_text()
    frontend_summary = (paths["frontend"] / "SUMMARY").read_text()
    
    # Check that delimiters are preserved
    assert "---\nFile:" in src_summary
    assert "---\nFile:" in frontend_summary
    
    # Check that content is propagated up
    js_content = (paths["js"] / "SUMMARY").read_text()
    assert js_content in src_summary
    assert js_content in frontend_summary

def test_aggregation_with_empty_directories(temp_project_dir):
    """Test that empty directories don't affect aggregation."""
    paths = create_nested_summaries(temp_project_dir)
    
    # Add an empty directory
    empty_dir = paths["src"] / "empty"
    empty_dir.mkdir()
    
    generator = SummaryGenerator(temp_project_dir)
    generator.generate_all_summaries()
    
    src_summary = (paths["src"] / "SUMMARY").read_text()
    frontend_summary = (paths["frontend"] / "SUMMARY").read_text()
    
    # Empty directory should not affect content
    assert not (empty_dir / "SUMMARY").exists()
    assert src_summary == frontend_summary

def test_aggregation_content_preservation(temp_project_dir):
    """Test that all content is preserved during aggregation."""
    paths = create_nested_summaries(temp_project_dir)
    
    generator = SummaryGenerator(temp_project_dir)
    generator.generate_all_summaries()
    
    # Get all unique content from leaf SUMMARYs
    leaf_content = set()
    for dir_name in ["js", "styles", "templates"]:
        summary = (paths[dir_name] / "SUMMARY").read_text()
        leaf_content.update(line for line in summary.splitlines() if line.strip())
    
    # Check that all content appears in parent summaries
    src_summary = (paths["src"] / "SUMMARY").read_text()
    frontend_summary = (paths["frontend"] / "SUMMARY").read_text()
    
    for line in leaf_content:
        if line.strip():  # Skip empty lines
            assert line in src_summary
            assert line in frontend_summary

def test_aggregation_with_excluded_directories(temp_project_dir):
    """Test that excluded directories don't affect aggregation."""
    paths = create_nested_summaries(temp_project_dir)
    
    # Create an excluded directory with content
    excluded_dir = paths["src"] / "__pycache__"
    excluded_dir.mkdir()
    (excluded_dir / "cache.pyc").write_text("cache content")
    
    generator = SummaryGenerator(temp_project_dir)
    generator.generate_all_summaries()
    
    src_summary = (paths["src"] / "SUMMARY").read_text()
    
    # Verify excluded content is not present
    assert "cache content" not in src_summary
    assert "__pycache__" not in src_summary



---
File: tests/test_summary/test_concatenative.py
---
# tests/test_summary/test_concatenative.py
import pytest
from pathlib import Path
from llamero.summary.concatenative import SummaryGenerator

@pytest.fixture
def config_project_dir(temp_project_dir):
    """Create a project directory with custom configuration."""
    config_content = """
[project]
name = "test-project"
description = "Test project"
version = "0.1.0"

[tool.summary]
max_file_size_kb = 10
exclude_patterns = [
    '.hidden',
    'excluded_file.txt',
    'temp'
]
include_extensions = [
    '.py',
    '.md',
    '.txt',
    '.custom'
]
exclude_directories = [
    'excluded_dir',
    'temp_dir',
    'data'
]
"""
    (temp_project_dir / "pyproject.toml").write_text(config_content)
    return temp_project_dir

@pytest.fixture
def workflow_project_dir(temp_project_dir):
    """Create a project directory with workflow files."""
    # Create workflow file
    workflow_dir = temp_project_dir / ".github" / "workflows"
    workflow_dir.mkdir(parents=True)
    (workflow_dir / "test.yml").write_text("name: Test")
    
    # Add basic pyproject.toml
    config_content = """
[project]
name = "test-project"
description = "Test project"
version = "0.1.0"
"""
    (temp_project_dir / "pyproject.toml").write_text(config_content)
    return temp_project_dir

@pytest.fixture
def test_files(config_project_dir):
    """Create a set of test files with various extensions and patterns."""
    # Create test files
    files = {
        # Should be included
        'test.py': 'print("Hello")',
        'doc.md': '# Documentation',
        'notes.txt': 'Some notes',
        'special.custom': 'Custom file',
        'nested/test.py': 'nested = True',
        
        # Should be excluded by pattern
        '.hidden/secret.txt': 'secret',
        'excluded_file.txt': 'excluded',
        'temp/data.py': 'temp data',
        
        # Should be excluded by extension
        'script.sh': '#!/bin/bash',
        'data.csv': 'a,b,c',
        
        # Should be excluded by directory
        'excluded_dir/test.py': 'excluded',
        'temp_dir/data.txt': 'temp',
        
        # Should be excluded by size (if >10KB)
        'large.py': 'x' * (11 * 1024)  # 11KB
    }
    
    for path, content in files.items():
        file_path = config_project_dir / path
        file_path.parent.mkdir(parents=True, exist_ok=True)
        file_path.write_text(content)
        
    return config_project_dir

def test_config_loading(config_project_dir):
    """Test that configuration is properly loaded from pyproject.toml."""
    generator = SummaryGenerator(config_project_dir)
    
    assert generator.max_file_size == 10 * 1024
    assert '.hidden' in generator.config['exclude_patterns']
    assert '.custom' in generator.config['include_extensions']
    assert 'excluded_dir' in generator.config['exclude_directories']

def test_file_inclusion_by_extension(test_files):
    """Test that files are correctly included/excluded based on extension."""
    generator = SummaryGenerator(test_files)
    
    # Should include
    assert generator.should_include_file(test_files / 'test.py')
    assert generator.should_include_file(test_files / 'doc.md')
    assert generator.should_include_file(test_files / 'special.custom')
    
    # Should exclude
    assert not generator.should_include_file(test_files / 'script.sh')
    assert not generator.should_include_file(test_files / 'data.csv')

def test_file_exclusion_by_pattern(test_files):
    """Test that files are correctly excluded based on patterns."""
    generator = SummaryGenerator(test_files)
    
    # Should exclude
    assert not generator.should_include_file(test_files / '.hidden/secret.txt')
    assert not generator.should_include_file(test_files / 'excluded_file.txt')
    assert not generator.should_include_file(test_files / 'temp/data.py')

def test_directory_exclusion(test_files):
    """Test that directories are correctly excluded."""
    generator = SummaryGenerator(test_files)
    
    # Should exclude
    assert not generator.should_include_directory(test_files / 'excluded_dir')
    assert not generator.should_include_directory(test_files / 'temp_dir')
    
    # Should include
    assert generator.should_include_directory(test_files / 'nested')

def test_file_size_limits(test_files):
    """Test that files are excluded based on size limits."""
    generator = SummaryGenerator(test_files)
    
    # Small file should be included
    assert generator.should_include_file(test_files / 'test.py')
    
    # Large file should be excluded
    assert not generator.should_include_file(test_files / 'large.py')


# def test_summary_generation_with_config(test_files):
#     """Test that summary generation respects all configuration settings."""
#     # Create test file in root
#     root_test_file = test_files / "test.py"
#     root_test_file.write_text("print('root')")
    
#     generator = SummaryGenerator(test_files)
#     summary_files = generator.generate_all_summaries()
    
#     # Get all generated summaries
#     summaries = {}
#     for summary_file in summary_files:
#         summaries[summary_file] = summary_file.read_text()
    
#     # Check that the right files were included
#     root_summary = test_files / 'SUMMARY'
#     if root_summary in summaries:
#         content = summaries[root_summary]
        
#         # Should include file with correct relative path
#         #assert 'File: test.py' in content, "Root file not found with correct path"
#         assert 'File: nested/test.py' in content, "Nested file not found"
#         assert 'File: src/test_project/main.py' in content, "Project file not found"
        
#         assert 'File: doc.md' in content
#         assert 'File: special.custom' in content
        
#         # Should exclude
#         assert 'excluded_file.txt' not in content
#         assert 'secret.txt' not in content
#         assert 'script.sh' not in content
#         assert 'large.py' not in content

def test_nested_directory_handling(test_files):
    """Test that nested directories are handled correctly."""
    generator = SummaryGenerator(test_files)
    summary_files = generator.generate_all_summaries()
    
    # Check nested directory summary
    nested_summary = test_files / 'nested' / 'SUMMARY'
    assert nested_summary.exists()
    content = nested_summary.read_text()
    
    assert 'File: nested/test.py' in content
    assert 'nested = True' in content

def test_default_config_fallback(temp_project_dir):
    """Test that default configuration is used when no config file exists."""
    # Create a test.py file
    (temp_project_dir / "test.py").write_text("print('test')")
    
    generator = SummaryGenerator(temp_project_dir)
    
    # Check default extensions
    assert generator.should_include_file(temp_project_dir / "test.py")
    
    # Create files with extensions that should be excluded by default
    test_sh = temp_project_dir / "script.sh"
    test_sh.write_text("#!/bin/bash")
    assert not generator.should_include_file(test_sh)
    
    # Check default directory exclusions
    git_dir = temp_project_dir / ".git"
    git_dir.mkdir(exist_ok=True)
    assert not generator.should_include_directory(git_dir)

def test_workflow_directory_mapping(workflow_project_dir):
    """Test that .github/workflows is correctly mapped to github/workflows."""
    generator = SummaryGenerator(workflow_project_dir)
    
    # Add a workflow file
    workflow_dir = workflow_project_dir / ".github" / "workflows"
    (workflow_dir / "test.yml").write_text("name: Test")
    
    summary_files = generator.generate_all_summaries()
    
    # Check that workflow summary was created in mapped location
    mapped_summary = workflow_project_dir / "github" / "workflows" / "SUMMARY"
    assert mapped_summary in summary_files
    
    # Verify content references original path
    content = mapped_summary.read_text()
    assert "File: .github/workflows/test.yml" in content

def test_error_handling(config_project_dir, caplog):
    """Test error handling for unreadable files."""
    caplog.set_level("ERROR")
    
    # Create unreadable file
    bad_file = config_project_dir / "unreadable.py"
    bad_file.write_text("test")
    
    try:
        # Make file unreadable
        bad_file.chmod(0o000)
        
        generator = SummaryGenerator(config_project_dir)
        generator.generate_directory_summary(config_project_dir)
        
        # Check for error message
        for record in caplog.records:
            if (
                record.levelname == "ERROR" 
                and "Error processing" in record.message 
                and "Permission denied" in record.message
            ):
                break
        else:
            pytest.fail("Expected error message not found in logs")
            
    finally:
        # Clean up
        bad_file.chmod(0o644)
        bad_file.unlink()

def test_excluded_directory_files(test_files):
    """Test that files in excluded directories are excluded regardless of extension."""
    # Create a file with valid extension in excluded directory
    excluded_dir = test_files / "data"
    excluded_dir.mkdir(exist_ok=True)
    test_file = excluded_dir / "_excluded_test.py"
    test_file.write_text("print('should be excluded')")
    
    generator = SummaryGenerator(test_files)
    
    # File should be excluded because it's in an excluded directory
    assert not generator.should_include_file(test_file)
    
    # Generate summary and verify file is not included
    summaries = generator.generate_all_summaries()
    for summary_file in summaries:
        content = summary_file.read_text()
        assert "_excluded_test.py" not in content
        assert "should be excluded" not in content



---
File: tests/test_summary/test_python_signatures.py
---
# tests/test_summary/test_python_signatures.py
import pytest
from llamero.summary.python_signatures import SignatureExtractor, generate_python_summary

def test_signature_extraction():
    """Test Python signature extraction."""
    source = """
def test_func(x: int, y: str = "default") -> bool:
    \"\"\"Test function.\"\"\"
    return True

class TestClass:
    \"\"\"Test class.\"\"\"
    def method(self, x: int) -> None:
        \"\"\"Test method.\"\"\"
        pass
    """
    
    extractor = SignatureExtractor()
    signatures = extractor.extract_signatures(source)
    
    assert len(signatures) == 2
    
    # Check function signature
    func = signatures[0]
    assert func.name == "test_func"
    assert func.kind == "function"
    assert len(func.args) == 2
    assert func.returns == "bool"
    assert func.docstring == "Test function."
    
    # Check class signature
    cls = signatures[1]
    assert cls.name == "TestClass"
    assert cls.kind == "class"
    assert cls.docstring == "Test class."
    assert len(cls.methods) == 1
    
    # Check method signature
    method = cls.methods[0]
    assert method.name == "method"
    assert method.kind == "method"
    assert len(method.args) == 2  # including self
    assert method.returns == "None"
    assert method.docstring == "Test method."


def test_generate_python_summary(temp_project_dir):
    """Test Python summary generation."""
    # Create a Python file with known content
    python_file = temp_project_dir / "src" / "test_project" / "main.py"
    python_content = """
def hello():
    \"\"\"Say hello.\"\"\"
    return "Hello, world!"

class TestClass:
    \"\"\"A test class.\"\"\"
    def method(self):
        \"\"\"A test method.\"\"\"
        return True
"""
    python_file.write_text(python_content)
    
    summary = generate_python_summary(temp_project_dir)
    
    # Check summary content - using exact signature format
    expected_fragments = [
        "# Python Project Structure",
        "def hello()",
        'class TestClass'
    ]
    for fragment in expected_fragments:
        assert fragment in summary, f"Missing expected content: {fragment}"



---
File: tests/test_summary/test_size_limits.py
---
# tests/test_summary/test_size_limits.py
import pytest
from pathlib import Path
import os
from llamero.summary.concatenative import SummaryGenerator

def test_file_size_threshold_config(temp_project_dir, monkeypatch):
    """Test that size threshold is properly loaded from config."""
    # Change to temp directory so it's treated as project root
    monkeypatch.chdir(temp_project_dir)
    
    # Update pyproject.toml with size threshold
    config_content = """
[project]
name = "test-project"
description = "Test project"
version = "0.1.0"

[tool.summary]
max_file_size_kb = 10  # 10KB threshold
"""
    (temp_project_dir / "pyproject.toml").write_text(config_content)
    
    generator = SummaryGenerator(temp_project_dir)
    assert generator.max_file_size == 10 * 1024  # Should be converted to bytes

def test_file_size_filtering(temp_project_dir, monkeypatch):
    """Test that files are filtered based on size."""
    # Change to temp directory so it's treated as project root
    monkeypatch.chdir(temp_project_dir)
    
    # Set up config with 1KB threshold
    config_content = """
[project]
name = "test-project"
description = "Test project"
version = "0.1.0"

[tool.summary]
max_file_size_kb = 1  # 1KB threshold
"""
    (temp_project_dir / "pyproject.toml").write_text(config_content)
    
    # Create test files
    small_file = temp_project_dir / "small.py"
    large_file = temp_project_dir / "large.py"
    
    # 500 bytes file (under threshold)
    small_file.write_text("x" * 500)
    
    # 2KB file (over threshold)
    large_file.write_text("x" * 2048)
    
    generator = SummaryGenerator(temp_project_dir)
    
    # Test individual file inclusion
    assert generator.should_include_file(small_file)
    assert not generator.should_include_file(large_file)

def test_directory_summary_with_size_limit(temp_project_dir, monkeypatch):
    """Test that directory summaries respect size limits."""
    # Change to temp directory so it's treated as project root
    monkeypatch.chdir(temp_project_dir)
    
    # Set up config with 1KB threshold
    config_content = """
[project]
name = "test-project"
description = "Test project"
version = "0.1.0"

[tool.summary]
max_file_size_kb = 1
"""
    (temp_project_dir / "pyproject.toml").write_text(config_content)
    
    # Create test files in a subdirectory
    test_dir = temp_project_dir / "test_dir"
    test_dir.mkdir()
    
    small_file = test_dir / "small.py"
    large_file = test_dir / "large.py"
    
    small_content = "def small_function():\n    pass"
    large_content = "x" * 2048  # 2KB of content
    
    small_file.write_text(small_content)
    large_file.write_text(large_content)
    
    generator = SummaryGenerator(temp_project_dir)
    summary = generator.generate_directory_summary(test_dir)
    
    # Summary should include small file but not large file
    assert "small.py" in summary
    assert "small_function" in summary
    assert "large.py" not in summary
    assert large_content not in summary

# def test_size_limit_warning_logging(temp_project_dir, monkeypatch, caplog):
#     """Test that appropriate warnings are logged for skipped files."""
#     # Change to temp directory so it's treated as project root
#     monkeypatch.chdir(temp_project_dir)
#     caplog.set_level("WARNING")
    
#     # Set up config with 1KB threshold
#     config_content = """
# [project]
# name = "test-project"
# description = "Test project"
# version = "0.1.0"

# [tool.summary]
# max_file_size_kb = 1
# """
#     (temp_project_dir / "pyproject.toml").write_text(config_content)
    
#     # Create a large file
#     large_file = temp_project_dir / "large.py"
#     large_file.write_text("x" * 2048)  # 2KB
    
#     generator = SummaryGenerator(temp_project_dir)
#     generator.generate_directory_summary(temp_project_dir)
    
#     # Check that a warning was logged
#     assert any([
#         "Skipping large file" in record.message and "large.py" in record.message
#         for record in caplog.records
#     ])



---
File: tests/test_summary/test_workflow_mapping.py
---
# tests/test_summary/test_workflow_mapping.py
import pytest
from pathlib import Path
from llamero.summary.concatenative import SummaryGenerator

def test_directory_mapping(temp_project_dir):
    """Test that .github/workflows maps to github/workflows."""
    generator = SummaryGenerator(temp_project_dir)
    
    # Test workflow directory mapping
    original = Path(".github/workflows")
    mapped = generator._map_directory(original)
    # We want just the mapped path without the root directory
    mapped_relative = mapped.relative_to(generator.root_dir) if mapped.is_absolute() else mapped
    assert str(mapped_relative) == "github/workflows"
    
    # Test that other directories aren't affected
    normal_dir = Path("src/llamero")
    mapped_normal = generator._map_directory(normal_dir)
    mapped_normal_relative = mapped_normal.relative_to(generator.root_dir) if mapped_normal.is_absolute() else mapped_normal
    assert str(mapped_normal_relative) == str(normal_dir)

def test_workflow_summary_generation(temp_project_dir):
    """Test generation of workflow summaries in mapped location."""
    # Create workflow dir and file
    workflow_dir = temp_project_dir / ".github" / "workflows"
    workflow_dir.mkdir(parents=True)
    
    workflow_content = """
name: Test Workflow
on: [push]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
"""
    (workflow_dir / "test.yml").write_text(workflow_content)
    
    # Generate summaries
    generator = SummaryGenerator(temp_project_dir)
    summary_files = generator.generate_all_summaries()
    
    # Check that summary was created in mapped location
    mapped_summary = temp_project_dir / "github" / "workflows" / "SUMMARY"
    assert mapped_summary in summary_files
    assert mapped_summary.exists()
    
    # Verify content
    content = mapped_summary.read_text()
    assert "File: .github/workflows/test.yml" in content

def test_mixed_directory_handling(temp_project_dir):
    """Test handling of both workflow and non-workflow directories."""
    # Create workflow file
    workflow_dir = temp_project_dir / ".github" / "workflows"
    workflow_dir.mkdir(parents=True)
    (workflow_dir / "test.yml").write_text("name: Test")
    
    # Create regular file
    src_dir = temp_project_dir / "src" / "llamero"
    src_dir.mkdir(parents=True)
    (src_dir / "test.py").write_text("print('test')")
    
    # Generate summaries
    generator = SummaryGenerator(temp_project_dir)
    summary_files = generator.generate_all_summaries()
    
    # Check both summaries
    workflow_summary = temp_project_dir / "github" / "workflows" / "SUMMARY"
    src_summary = src_dir / "SUMMARY"
    
    assert workflow_summary in summary_files
    assert workflow_summary.exists()
    assert src_summary in summary_files
    assert src_summary.exists()



---
File: tests/test_tree_generator.py
---
from loguru import logger
from pathlib import Path
import pytest
from llamero.tree_generator import (
    should_include_path,
    node_to_tree,
    generate_tree
)

@pytest.fixture
def mock_repo_with_files(mock_git_repo):
    """Extend mock_git_repo with additional test files"""
    # Add workflow files
    workflow_dir = mock_git_repo / ".github" / "workflows"
    workflow_dir.mkdir(parents=True)
    (workflow_dir / "test.yml").write_text("name: Test")
    (workflow_dir / "build.yml").write_text("name: Build")
    
    # Add various hidden files
    (mock_git_repo / ".env").write_text("SECRET=123")
    (mock_git_repo / ".github" / "README.md").write_text("# GitHub Config")
    
    # Add some regular files and directories
    docs_dir = mock_git_repo / "docs" / "readme" / "sections"
    docs_dir.mkdir(parents=True, exist_ok=True)
    (docs_dir / "introduction.md").write_text("# Intro")
    
    # Add some files that should typically be ignored
    cache_dir = mock_git_repo / "__pycache__"
    cache_dir.mkdir(exist_ok=True)
    (cache_dir / "module.pyc").write_text("cache")
    
    return mock_git_repo

def test_ignore_patterns(mock_git_repo):
    """Test that ignore patterns work correctly"""
    config = {
        "tool": {
            "readme": {
                "tree": {
                    "ignore_patterns": [".git", "__pycache__", "*.pyc"]
                }
            }
        }
    }
    
    # Should exclude based on exact pattern matches
    assert not should_include_path(Path(".git/config"), config)
    assert not should_include_path(Path("foo/__pycache__/bar.pyc"), config)
    assert not should_include_path(Path("test.pyc"), config)
    
    # Should include non-matching paths
    assert should_include_path(Path(".github/workflows/test.yml"), config)
    assert should_include_path(Path(".env"), config)
    assert should_include_path(Path("docs/readme/file.md"), config)
    assert should_include_path(Path("src/test_project/main.py"), config)

def test_full_tree_generation(mock_repo_with_files, monkeypatch):
    """Test complete tree generation with various file types"""
    monkeypatch.chdir(mock_repo_with_files)
    
    # Update existing pyproject.toml with tree config
    config_content = """
[project]
name = "test-project"
description = "Test project"
version = "0.1.0"
requires-python = ">=3.11"

[tool.llamero]
verbose = true

[tool.readme.tree]
ignore_patterns = ["__pycache__", "*.pyc", ".git"]
"""
    (mock_repo_with_files / "pyproject.toml").write_text(config_content)
    
    tree = generate_tree(".")
    print(f"Generated tree:\n{tree}")  # Keep for debugging
    
    tree_lines = tree.splitlines()
    
    # Should include .github and workflows
    assert any(".github" in line for line in tree_lines)
    assert any("workflows" in line for line in tree_lines)
    assert any("test.yml" in line for line in tree_lines)
    assert any("build.yml" in line for line in tree_lines)
    
    # Should include other files from mock_git_repo
    assert any("src" in line for line in tree_lines)
    assert any("test_project" in line for line in tree_lines)
    assert any("main.py" in line for line in tree_lines)
    
    # Should include added test files
    assert any(".env" in line for line in tree_lines)
    assert any("docs" in line for line in tree_lines)
    assert any("readme" in line for line in tree_lines)
    assert any("sections" in line for line in tree_lines)
    
    # Should exclude ignored patterns - check each line individually
    assert not any(line.strip().endswith("__pycache__") for line in tree_lines)
    assert not any(line.strip().endswith(".git") for line in tree_lines)
    assert not any(line.endswith(".pyc") for line in tree_lines)

def test_empty_directory_handling(mock_git_repo):
    """Test handling of empty directories"""
    # Create some empty directories
    (mock_git_repo / "docs" / "empty").mkdir(parents=True, exist_ok=True)
    (mock_git_repo / "src" / "empty").mkdir(parents=True, exist_ok=True)
    (mock_git_repo / "temp" / "empty").mkdir(parents=True, exist_ok=True)
    
    config = {
        "tool": {
            "readme": {
                "tree": {
                    "ignore_patterns": []
                }
            }
        }
    }
    
    # Empty directories should be excluded unless they're essential
    assert node_to_tree(mock_git_repo / "temp" / "empty", config) is None
    
    # Essential directories should be kept even if empty
    assert node_to_tree(mock_git_repo / "docs", config) is not None
    assert node_to_tree(mock_git_repo / "src", config) is not None

def test_debug_path_processing(mock_repo_with_files):
    """Debug test to print path processing details"""
    config = {
        "tool": {
            "readme": {
                "tree": {
                    "ignore_patterns": ["__pycache__", "*.pyc"]
                }
            }
        }
    }
    
    def debug_walk(path: Path, indent=""):
        logger.debug(f"{indent}Processing: {path}")
        logger.debug(f"{indent}Should include: {should_include_path(path, config)}")
        
        if path.is_dir():
            for child in sorted(path.iterdir()):
                debug_walk(child, indent + "  ")
    
    logger.debug("Starting debug walk of repository")
    debug_walk(mock_repo_with_files)



---
File: tests/test_utils.py
---
# tests/test_utils.py
import pytest
from pathlib import Path
import os
from llamero.utils import get_project_root, load_config

def test_get_project_root(temp_project_dir):
    """Test project root detection."""
    os.chdir(temp_project_dir)
    root = get_project_root()
    assert root == temp_project_dir
    assert (root / "pyproject.toml").exists()

def test_get_project_root_subfolder(temp_project_dir):
    """Test project root detection from subfolder."""
    subfolder = temp_project_dir / "src"
    os.chdir(subfolder)
    root = get_project_root()
    assert root == temp_project_dir

def test_load_config(temp_project_dir):
    """Test configuration loading."""
    os.chdir(temp_project_dir)
    config = load_config("pyproject.toml")
    assert config["project"]["name"] == "test-project"
    assert config["tool"]["llamero"]["verbose"] is True

def test_load_config_missing():
    """Test loading missing configuration."""
    with pytest.raises(FileNotFoundError):
        load_config("nonexistent.toml")
